package com.incquerylabs.emdw.umlintegration.queries

import "http://www.eclipse.org/uml2/5.0.0/UML" as uml
import "http://www.zeligsoft.com/xtumlrt/common" as common
import "http://incquerylabs.com/emdw/umlintegration/trace"

pattern rootMapping(rootMapping, umlRoot, xtumlrtRoot) {
	RootMapping.umlRoot(rootMapping, umlRoot);
	RootMapping.xtumlrtRoot(rootMapping, xtumlrtRoot);	
}

pattern trace(rootMapping, trace, umlElement, xtumlrtElement) {
	RootMapping.traces(rootMapping, trace);
	Trace.umlElements(trace, umlElement);
	Trace.xtumlrtElements(trace, xtumlrtElement);
}

pattern behavioredClassifier(umlPackage: uml::Package, behavioredClassifier: BehavioredClassifier) {
	uml::Package.packagedElement(umlPackage, behavioredClassifier);
}

pattern stateMachine(behavioredClassifier: BehavioredClassifier, stateMachine: uml::StateMachine) {
	BehavioredClassifier.classifierBehavior(behavioredClassifier, stateMachine);
}

private pattern pseudostateOfRegion(region: Region, pseudostate: uml::Pseudostate, kind: PseudostateKind) {
	Region.subvertex(region, pseudostate);
	uml::Pseudostate.kind(pseudostate, kind);
}

// Initial state

pattern initialState(pseudostate: uml::Pseudostate) {
	find toplevelInitialState(_, pseudostate);
} or {
	find childInitialState(_, pseudostate);
}

pattern toplevelInitialState(stateMachine: uml::StateMachine, pseudostate: uml::Pseudostate) {
	uml::StateMachine.region(stateMachine, region);
	find pseudostateOfRegion(region, pseudostate, PseudostateKind::initial);
}

pattern childInitialState(state: uml::State, pseudostate: uml::Pseudostate) {
	uml::State.region(state, region);
	find pseudostateOfRegion(region, pseudostate, PseudostateKind::initial);
}

// Choice state

pattern choiceState(pseudostate: uml::Pseudostate) {
	find toplevelChoiceState(_, pseudostate);
} or {
	find childChoiceState(_, pseudostate);
}

pattern toplevelChoiceState(stateMachine: uml::StateMachine, pseudostate: uml::Pseudostate) {
	uml::StateMachine.region(stateMachine, region);
	find pseudostateOfRegion(region, pseudostate, PseudostateKind::choice);
}

pattern childChoiceState(state: uml::State, pseudostate: uml::Pseudostate) {
	uml::State.region(state, region);
	find pseudostateOfRegion(region, pseudostate, PseudostateKind::choice);
}

// Simple state

pattern simpleState(state: uml::State) {
	find toplevelSimpleState(_, state);
} or {
	find childSimpleState(_, state);
}

pattern toplevelSimpleState(stateMachine: uml::StateMachine, state: uml::State) {
	uml::StateMachine.region(stateMachine, region);
	Region.subvertex(region, state);
	neg find region(state, _);
}

pattern childSimpleState(parentState: uml::State, state: uml::State) {
	uml::State.region(parentState, region);
	Region.subvertex(region, state);
	neg find region(state, _);
}

// Composite state

pattern compositeState(state: uml::State) {
	find toplevelCompositeState(_, state);
} or {
	find childCompositeState(_, state);
}

pattern toplevelCompositeState(stateMachine: uml::StateMachine, state: uml::State) {
	uml::StateMachine.region(stateMachine, region);
	Region.subvertex(region, state);
	find region(state, _);
}

pattern childCompositeState(parentState: uml::State, state: uml::State) {
	uml::State.region(parentState, region);
	Region.subvertex(region, state);
	find region(state, _);
}

private pattern region(state: uml::State, region: Region) {
	uml::State.region(state, region);
}

// Transition

pattern transition(transition: uml::Transition, sourceState: uml::Vertex, targetState: uml::Vertex) {
	find toplevelTransition(_, transition, sourceState, targetState);
} or {
	find childTransition(_, transition, sourceState, targetState);
}

pattern toplevelTransition(stateMachine: uml::StateMachine, transition: uml::Transition, sourceState: uml::Vertex, targetState: uml::Vertex) {
	uml::StateMachine.region(stateMachine, region);
	find transitionOfRegion(region, transition, sourceState, targetState);
}

pattern childTransition(parentState: uml::State, transition: uml::Transition, sourceState: uml::Vertex, targetState: uml::Vertex) {
	uml::State.region(parentState, region);
	find transitionOfRegion(region, transition, sourceState, targetState);
}

private pattern transitionOfRegion(region: Region, transition: uml::Transition, sourceState: uml::Vertex, targetState: uml::Vertex) {
	uml::Region.transition(region, transition);
	Region.subvertex(region, sourceState);
	Region.subvertex(region, targetState);
	uml::Transition.source(transition, sourceState);
	uml::Transition.target(transition, targetState);
}
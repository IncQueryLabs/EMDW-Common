/*
 * generated by Xtext
 */
package com.incquerylabs.uml.ralf.scoping

import com.google.inject.Inject
import com.incquerylabs.uml.ralf.ReducedAlfSystem
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Block
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Expression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.PropertyAccessExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Statement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Statements
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Variable
import org.eclipse.emf.ecore.EClass
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.xtext.util.PolymorphicDispatcher

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
class ReducedAlfLanguageScopeProvider extends AbstractDeclarativeScopeProvider {

    @Inject
    IUMLContextProvider umlContext;
    @Inject
    ReducedAlfSystem system;
    
//    override getPredicate(EObject context, EClass type) {
//        val methodName = "scope_" + type.name
//        println(methodName + " with context " + context.eClass.name)
//        return PolymorphicDispatcher.Predicates.forName(methodName, 2)
//    }
//
//    override getPredicate(EObject context, EReference reference) {
//        val methodName = "scope_" + reference.EContainingClass.name + "_" + reference.name
//        println(methodName + " with context " + context.eClass.name)
//        return PolymorphicDispatcher.Predicates.forName(methodName, 2)
//    }
    
    def IScope scope_Type(EObject context, EReference reference) {
        if (umlContext == null) {
            IScope.NULLSCOPE
        } else {
               Scopes.scopeFor(umlContext.knownTypes)
        }
    }
    
    def IScope scope_Classifier(EObject context, EReference reference) {
        if (umlContext == null) {
            IScope.NULLSCOPE
        } else {
               Scopes.scopeFor(umlContext.knownClasses,
                    Scopes.scopeFor(umlContext.knownSignals)
               )
        }
    }
    
    def IScope scope_Class(EObject context, EReference reference) {
        if (umlContext == null) {
            IScope.NULLSCOPE
        } else {
               Scopes.scopeFor(umlContext.knownClasses)
        }
    }
    
    def IScope scope_Signal(EObject context, EReference reference) {
        if (umlContext == null) {
            IScope.NULLSCOPE
        } else {
               Scopes.scopeFor(umlContext.knownSignals)
        }
    }
    
    def scope_Variable(Expression context, EReference reference) {
        val scope = scope_Variable(context)
        scope
    }
    
    private def IScope scope_Variable(EObject block) {
        var parentBlock = block.eContainer
        if (parentBlock == null) {
            IScope.NULLSCOPE
        } else {
            val parentScope = scope_Variable(parentBlock)
            val declarations = parentBlock.variableDeclarations(block)
            if (declarations.nullOrEmpty) {
                parentScope
            } else {
                Scopes.scopeFor(declarations, parentScope)
            }
        }
    }
    
    private def variableDeclarations(EObject container, EObject until) {
        switch (container) {
          Block:  
            container.statement.
                takeWhile[it != until].
                map[eContents.filter(Variable)].
                flatten
          Statements: container.statement.
                takeWhile[it != until].
                map[eContents.filter(Variable)].
                flatten
          Statement: 
            container.eContents.
                takeWhile[it != until].
                filter(Variable)
          default:
            emptyList
        }
    }
    
    def IScope scope_PropertyAccessExpression_property(PropertyAccessExpression ctx, EReference ref) {
        if (ctx.context != null && !(ctx.context.eIsProxy)) {
            scope_PropertyAccessExpression_property(ctx.context, ref)
        } else {
            null
        }
    }
    
    def IScope scope_PropertyAccessExpression_property(Expression ctx, EReference ref) {
        val typeResult = system.type(ctx)
        if (typeResult.failed) {
            return null
        }
        val type = typeResult.value
        if (type instanceof org.eclipse.uml2.uml.Class) {
            Scopes.scopeFor(umlContext.getPropertiesOfClass(type))
        } else {
            null
        }
    }
}

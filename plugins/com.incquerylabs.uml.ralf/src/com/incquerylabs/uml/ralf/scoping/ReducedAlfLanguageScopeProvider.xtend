/*******************************************************************************
 * Copyright (c) 2015-2016, IncQuery Labs Ltd. and Ericsson AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Akos Horvath, Abel Hegedus, Zoltan Ujhelyi, Peter Lunk - initial API and implementation
 *******************************************************************************/
/*
 * generated by Xtext
 */
package com.incquerylabs.uml.ralf.scoping

import com.google.common.collect.Iterables
import com.google.inject.Inject
import com.incquerylabs.uml.ralf.ReducedAlfSystem
import com.incquerylabs.uml.ralf.reducedAlfLanguage.AssociationAccessExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Block
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Expression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FeatureInvocationExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FilterExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ForEachStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ForStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Statement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Statements
import com.incquerylabs.uml.ralf.reducedAlfLanguage.StaticFeatureInvocationExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Variable
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.emf.ecore.util.EcoreUtil
import org.eclipse.uml2.uml.Class
import org.eclipse.uml2.uml.Classifier
import org.eclipse.uml2.uml.NamedElement
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.naming.QualifiedName
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import com.google.common.base.Function
import org.eclipse.xtext.scoping.impl.MapBasedScope
import com.incquerylabs.uml.ralf.scoping.context.IUMLContextProviderAccess
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ReducedAlfLanguagePackage

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
 
class ReducedAlfLanguageScopeProvider extends AbstractDeclarativeScopeProvider {
    
    @Inject
    ReducedAlfSystem system
    @Inject
    IQualifiedNameConverter nameConverter
    @Inject
    extension IUMLContextProviderAccess contextAccess
    
    private def scopeFor(Iterable<? extends EObject> elements) {
        scopeFor(elements, IScope.NULLSCOPE)
    }
    
    private def scopeFor(Iterable<? extends EObject> elements, IScope outer) {
        Scopes.scopeFor(elements, outer)
        //MapBasedScope.createScope(outer, Scopes.scopedElementsFor(elements))
    }
    
    private def <T extends EObject> IScope scopeFor(Iterable<? extends T> elements,
            Function<T, QualifiedName> nameComputation, IScope outer) {
        Scopes.scopeFor(elements, nameComputation, outer)
        //MapBasedScope.createScope(outer, Scopes.scopedElementsFor(elements, nameComputation))
    }
    
    def scope_NamedElement(Expression context, EReference reference) {
        val typeScope = delegateGetScope(context, reference) 
        //scopeOfTypes(context, context.umlContextProviderFor)
        val scope = if (context.eContainer instanceof StaticFeatureInvocationExpression) {
            scope_NamedElement(context, scope_StaticFeatureInvocationExpression_operation(context.eContainer as StaticFeatureInvocationExpression, reference))
        } else {
            scope_NamedElement(context, typeScope)
        }
        scope
    }
    
    def IScope scope_NamedElement(EObject block, IScope externalScope) {
        var parentBlock = block.eContainer
        if (parentBlock == null || parentBlock.eClass.EPackage.nsURI != ReducedAlfLanguagePackage.eNS_URI) {
            getParametersScope(externalScope, block.umlContextProviderFor, block)
        } else {
            val parentScope = scope_NamedElement(parentBlock, externalScope)
            val declarations = parentBlock.variableDeclarations(block)
            if (declarations.nullOrEmpty) {
                parentScope
            } else {
                scopeFor(declarations, parentScope)
            }
        }
    }
    
    protected def IScope getParametersScope(IScope parentScope, IUMLContextProvider umlContext, EObject _context) {
        var IScope returnScope = parentScope
        val operation = umlContext.getDefinedOperation(_context)
        if (operation == null) {
            returnScope
        } else {
            scopeFor(operation.ownedParameters, returnScope)
        }
    }
    
    private def Iterable<Variable> variableDeclarations(EObject container, EObject until) {
        switch (container) {
          Block:
            // Assumes all variable instances are directly contained in a declaration statement  
            container.statement.
                takeWhile[it != until].
                filter[
                	// The loop variable of a for each statement should not be visible
                	!(it instanceof ForEachStatement)
                	// It is not necessary to filter ForStatement as its variable is not directly contained
                ].
                map[eContents.filter(Variable)].
                flatten
          Statements: container.statement.
                takeWhile[it != until].
                map[eContents.filter(Variable)].
                flatten
          ForStatement: variableDeclarations(container.initialization, container)
          ForEachStatement : newArrayList(container.variableDefinition)
          FilterExpression : newArrayList(container.declaration)
          Statement: 
            container.eContents.
                takeWhile[it != until].
                filter(Variable)
          default:
            emptyList
        }
    }
     
    def IScope scope_FeatureInvocationExpression_feature(FeatureInvocationExpression ctx, EReference ref) {
        if (ctx.context != null) {
            EcoreUtil.resolveAll(ctx.context);
            scope_FeatureInvocationExpression_feature(ctx.context, ref)    
        } else {
            IScope.NULLSCOPE
        }
    }
    
    def IScope scope_FeatureInvocationExpression_feature(Expression ctx, EReference ref) {
        val typeResult = system.type(ctx)
        if (typeResult.failed) {
            return IScope.NULLSCOPE
        }
        val type = typeResult.value.umlType
        if (type instanceof Classifier) {
            val uml = ctx.umlContextProviderFor
            scopeFor(uml.getPropertiesOfClass(type),
                scopeFor(uml.getOperationsOfClass(type))
            )
        } else {
            IScope.NULLSCOPE
        }
    }
    
    def IScope scope_StaticFeatureInvocationExpression_operation(StaticFeatureInvocationExpression ctx, EReference ref) {
        val uml = ctx.umlContextProviderFor
        val staticScope = delegateGetScope(ctx, ref)
        val thisType = uml.getThisType(ctx)
        if (thisType != null) {
            scopeFor(uml.getOperationsOfClass(thisType),
                [
                    nameConverter.toQualifiedName(name)
                ],
                staticScope
            )
        } else {
            staticScope            
        }
    }
    
    def IScope scope_AssociationAccessExpression_association(AssociationAccessExpression ctx, EReference ref) {
        if (ctx.context != null && !(ctx.context.eIsProxy)) {
            scope_AssociationAccessExpression_association(ctx.context, ref)
        } else {
            IScope.NULLSCOPE
        }
    }
    
    def IScope scope_AssociationAccessExpression_association(Expression ctx, EReference ref) {
        val typeResult = system.type(ctx)
        if (typeResult.failed) {
            return IScope.NULLSCOPE
        }
        val type = typeResult.value.umlValueType
        
        if (type instanceof Class) {
            return scopeFor(ctx.umlContextProviderFor.getAssociationsOfClass(type))
        } 
        return IScope.NULLSCOPE
    }

}

/*
 * generated by Xtext
 */
package com.incquerylabs.uml.ralf.scoping

import com.google.inject.Inject
import com.incquerylabs.uml.ralf.ReducedAlfSystem
import com.incquerylabs.uml.ralf.reducedAlfLanguage.AssociationAccessExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Block
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Expression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FeatureInvocationExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.FilterExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ForEachStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.ForStatement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Statement
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Statements
import com.incquerylabs.uml.ralf.reducedAlfLanguage.StaticFeatureInvocationExpression
import com.incquerylabs.uml.ralf.reducedAlfLanguage.Variable
import com.incquerylabs.uml.ralf.types.UMLTypeReference
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.uml2.uml.Class
import org.eclipse.uml2.uml.Classifier
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.scoping.IScope
import org.eclipse.xtext.scoping.Scopes
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider
import org.eclipse.uml2.uml.NamedElement
import com.google.common.collect.Iterables
import org.eclipse.uml2.uml.PrimitiveType
import org.eclipse.xtext.naming.QualifiedName

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 *
 */
 
class ReducedAlfLanguageScopeProvider extends AbstractDeclarativeScopeProvider {

    @Inject
    IUMLContextProvider umlContext
    @Inject
    ReducedAlfSystem system
    @Inject
    IQualifiedNameConverter nameConverter
    
    def IScope scope_Type(EObject context, EReference reference) {
        if (umlContext == null) {
            IScope.NULLSCOPE
        } else {
            scopeOfTypes
        }
    }
    
    def IScope scope_Classifier(EObject context, EReference reference) {
        localAndQualifiedScopes(Iterables.<NamedElement>concat(umlContext.knownClasses, umlContext.knownSignals))
    }
    
    def IScope scope_Class(EObject context, EReference reference) {
        Scopes.scopeFor(umlContext.knownClasses)
    }
    
    def IScope scope_Signal(EObject context, EReference reference) {
        Scopes.scopeFor(umlContext.knownSignals)
    }
        
    def IScope scope_Association(EObject ctx, EReference ref) {
        Scopes.scopeFor(umlContext.knownAssociations)
    }
    
    def scope_NamedElement(Expression context, EReference reference) {
        val typeScope = scopeOfTypes
        val scope = if (context.eContainer instanceof StaticFeatureInvocationExpression) {
            scope_NamedElement(context, scope_StaticFeatureInvocationExpression_operation(context.eContainer as StaticFeatureInvocationExpression, reference))
        } else {
            scope_NamedElement(context, typeScope)
        }
        scope
    }
    
    def IScope scope_NamedElement(EObject block) {
        scope_NamedElement(block, scopeOfTypes)    
    }
    
    def IScope scope_NamedElement(EObject block, IScope externalScope) {
        var parentBlock = block.eContainer
        if (parentBlock == null) {
            getParametersScope(externalScope)
        } else {
            val parentScope = scope_NamedElement(parentBlock, externalScope)
            val declarations = parentBlock.variableDeclarations(block)
            if (declarations.nullOrEmpty) {
                parentScope
            } else {
                Scopes.scopeFor(declarations, parentScope)
            }
        }
    }
    
    private def IScope scopeOfTypes() {
        val knownTypes = umlContext.knownTypes
        localAndQualifiedScopes(knownTypes)
    }
    
    private def IScope localScope(Iterable<? extends NamedElement> elements, String qualifiedName, IScope parentScope) {
        if (qualifiedName != null) {
            val packageRelativeElements = elements.filter[
                it.qualifiedName != null &&
                it.qualifiedName.startsWith(qualifiedName + "::") &&
                it.qualifiedName != qualifiedName
            ]
            Scopes.scopeFor(packageRelativeElements, [NamedElement it |
                nameConverter.toQualifiedName(it.qualifiedName.substring(qualifiedName.length + 2)) //+2 '::'
            ], parentScope)
        } else {
            parentScope
        }
    }
    
    private def IScope localAndQualifiedScopes(Iterable<? extends NamedElement> elements) {
        val fqnScope = Scopes.scopeFor(elements.filter[it != null && !it.qualifiedName.nullOrEmpty], [NamedElement it|
            switch it {
            PrimitiveType : nameConverter.toQualifiedName(it.name)
            default: nameConverter.toQualifiedName(it.qualifiedName)
            }
        ], IScope.NULLSCOPE)
        val thisQualifiedName = umlContext?.thisType?.qualifiedName
        val containerQualifiedName = umlContext?.thisType?.namespace?.qualifiedName
        localScope(elements, thisQualifiedName, 
            localScope(elements, containerQualifiedName, fqnScope)
        )
    }
    
    private def IScope getParametersScope(IScope parentScope) {
        val operation = umlContext.definedOperation
        if (operation == null) {
            parentScope
        } else {
            Scopes.scopeFor(operation.ownedParameters, parentScope)
        }
    }
    
    private def Iterable<Variable> variableDeclarations(EObject container, EObject until) {
        switch (container) {
          Block:
            // Assumes all variable instances are directly contained in a declaration statement  
            container.statement.
                takeWhile[it != until].
                filter[
                	// The loop variable of a for each statement should not be visible
                	!(it instanceof ForEachStatement)
                	// It is not necessary to filter ForStatement as its variable is not directly contained
                ].
                map[eContents.filter(Variable)].
                flatten
          Statements: container.statement.
                takeWhile[it != until].
                map[eContents.filter(Variable)].
                flatten
          ForStatement: variableDeclarations(container.initialization, container)
          ForEachStatement : newArrayList(container.variableDefinition)
          FilterExpression : newArrayList(container.declaration)
          Statement: 
            container.eContents.
                takeWhile[it != until].
                filter(Variable)
          default:
            emptyList
        }
    }
     
    def IScope scope_FeatureInvocationExpression_feature(FeatureInvocationExpression ctx, EReference ref) {
        if (ctx.context != null && !ctx.context.eIsProxy) {
            scope_FeatureInvocationExpression_feature(ctx.context, ref)    
        } else {
            null
        }
    }
    
    def IScope scope_FeatureInvocationExpression_feature(Expression ctx, EReference ref) {
        val typeResult = system.type(ctx)
        if (typeResult.failed) {
            return null
        }
        val type = typeResult.value.umlType
        if (type instanceof Classifier) {
            Scopes.scopeFor(umlContext.getPropertiesOfClass(type),
                Scopes.scopeFor(umlContext.getOperationsOfClass(type))
            )
        } else {
            null
        }
    }
    
    def IScope scope_StaticFeatureInvocationExpression_operation(StaticFeatureInvocationExpression ctx, EReference ref) {
        val staticScope = umlContext.staticOperations.localAndQualifiedScopes
        val thisType = umlContext.thisType
        if (thisType != null) {
            Scopes.scopeFor(umlContext.getOperationsOfClass(thisType),
                [
                    nameConverter.toQualifiedName(name)
                ],
                staticScope
            )
        } else {
            staticScope            
        }
    }
    
    def IScope scope_AssociationAccessExpression_association(AssociationAccessExpression ctx, EReference ref) {
        if (ctx.context != null && !(ctx.context.eIsProxy)) {
            scope_AssociationAccessExpression_association(ctx.context, ref)
        } else {
            null
        }
    }
    
    def IScope scope_AssociationAccessExpression_association(Expression ctx, EReference ref) {
        val typeResult = system.type(ctx)
        if (typeResult.failed) {
            return null
        }
        val typeRef = typeResult.value
        if (typeRef instanceof UMLTypeReference) {
            val type = typeRef.umlType
            if (type instanceof Class) {
                return Scopes.scopeFor(umlContext.getAssociationsOfClass(type))
            } 
        }
        return null
    }

}
